=== tests/cases/conformance/types/objectTypeLiteral/constructSignatures/constructSignaturesWithAbstractOverloads.2.ts ===
interface C {
}

interface C2<T> {
}

interface I {
    abstract new(x: number, y?: string): C;
>x : number
>y : string

    new(x: number, y: string): C;
>x : number
>y : string
}

var i: I;
>i : I

var r3 = new i(1, '');
>r3 : any
>new i(1, '') : any
>i : I
>1 : 1
>'' : ""

interface I2<T> {
    abstract new (x: T, y?: string): C2<T>;
>x : T
>y : string

    new (x: T, y: string): C2<T>;
>x : T
>y : string

    abstract new <T>(x: T, y?: string): C2<T>;
>x : T
>y : string

    new <T>(x: T, y: string): C2<T>;
>x : T
>y : string

}

var i2: I2<number>;
>i2 : I2<number>

var r4 = new i2(1, '');
>r4 : any
>new i2(1, '') : any
>i2 : I2<number>
>1 : 1
>'' : ""

var a: {
>a : { abstract new (x: number, y?: string): C; new (x: number, y: string): C; }

    abstract new(x: number, y?: string): C;
>x : number
>y : string

    new(x: number, y: string): C;
>x : number
>y : string
}

var r5 = new a(1, '');
>r5 : any
>new a(1, '') : any
>a : { abstract new (x: number, y?: string): C; new (x: number, y: string): C; }
>1 : 1
>'' : ""

var b: {
>b : { new <T>(x: T, y?: string): C2<T>; abstract new <T>(x: T, y: string): C2<T>; }

    new<T>(x: T, y?: string): C2<T>;
>x : T
>y : string

    abstract new<T>(x: T, y: string): C2<T>;
>x : T
>y : string
}

var r6 = new b(1, '');
>r6 : C2<number>
>new b(1, '') : C2<number>
>b : { new <T>(x: T, y?: string): C2<T>; abstract new <T>(x: T, y: string): C2<T>; }
>1 : 1
>'' : ""

